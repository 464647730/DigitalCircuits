设计一
每个界面使用一个View类管理。
在程序的开始，实例化所有的View类，并且将其隐藏。
然后启动一个主view。
view之间可以跳转。跳转需要指定目标view以及传输的数据。传输的数据是自定义的，可以使用Object实现。
View在不显示时不能有任何反应，因此不能监听resize等事件。其他事件在隐藏之后都不在接受反应了。
view之间跳转的顺序和时机是由view自行决定的。这反应了作者的设计。如果设计更改，那么跳转也要更改。
数据的传输不在需要controller作为中介。而是在view之间直接传递，像一个接力棒。view可以创建数据，可以将其传递给下一个view。如果不再传递，那么数据就不再使用了。
在v1版本中，view的初始化可能需要其他view的数据。我可以更改设计，使之初始化时不需数据，在接受数据之后再进行调整。

这种方法必须实现创建所有的类。



设计二
将所有的view元素隐藏。
View类只有在启动之后才会实例化。
View可以销毁。
使用栈维护View列表和View之间的跳转。



设计三
设计一改进
将view进行注册，事先隐藏；或者使用样式将其隐藏，例如，我们可以创建view样式类。
View

采取设计一
简单



**
web的基本思路就是：实现写好所有的事件监听。
在其他语言中，只有在需要的时候才创建类。但是js一般写好所有类。

**
View之间有顺序。比如，B只能在A之后执行。
假设有连续的A，B，C三个View，A获取了一张用户打开的图片，B接受图片并且预览，再在C中编辑。C中编辑了一般，决定丢弃工作，返回上一页。这时，B的状态已经改变了，不能再重新创建实例。一开始的B是不包含图片的，但是现在包含了一张特定的图片。
可以从生命周期的视角来考虑。
这主要涉及数据的传递。
A传递数据给B，B的状态就改变了。B在进入C，C如果想要返回B，就需要返回那个状态改变了的B，因为B中保存着数据。如果重新实例化，就清除了B中的数据。
这其实是数据的保存问题。
比如A创建了数据data1，然后跳转至B。那么，A是否还需要继续保存数据data1？如果不必，就可以销毁，如果需要，就必须使用之前的A。
其实无论哪种情况都可以不销毁，因为View都是单例模式。可以写一个reset方法清除数据，返回初始化的状态。


** View的数据更新
View保存着数据。有些是自己创建的，有些是用户输入的，有些需要利用前一个View传递的数据。
比如A有数据data1，传递给B，B据此创建数据data2，那么重新由A进入B之后，B的data2必然会重建。
比如有经A，B，C的数据传递。如果A的数据改变了，那么B和C之前保存的旧数据就无用了。

**
这样看来，在初始时创建所有的View实例是可行的。虽然有些实例此时还没有准备好。比如B需要A传递的图片才能展示；B的元素不齐备，因此无法添加事件监听。
这些一方面可以通过修改设计避免；另一方面，由于只有在得到传递的数据之后才会展示，就避免了问题。



