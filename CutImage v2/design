设计一
每个界面使用一个View类管理。
在程序的开始，实例化所有的View类，并且将其隐藏。
然后启动一个主view。
view之间可以跳转。跳转需要指定目标view以及传输的数据。传输的数据是自定义的，可以使用Object实现。
View在不显示时不能有任何反应，因此不能监听resize等事件。其他事件在隐藏之后都不在接受反应了。
view之间跳转的顺序和时机是由view自行决定的。这反应了作者的设计。如果设计更改，那么跳转也要更改。
数据的传输不在需要controller作为中介。而是在view之间直接传递，像一个接力棒。view可以创建数据，可以将其传递给下一个view。如果不再传递，那么数据就不再使用了。
在v1版本中，view的初始化可能需要其他view的数据。我可以更改设计，使之初始化时不需数据，在接受数据之后再进行调整。

这种方法必须实现创建所有的类。



设计二
将所有的view元素隐藏。
View类只有在启动之后才会实例化。
View可以销毁。
使用栈维护View列表和View之间的跳转。



设计三
设计一改进
将view进行注册，事先隐藏；或者使用样式将其隐藏，例如，我们可以创建view样式类。
View

采取设计一
简单



**
web的基本思路就是：实现写好所有的事件监听。
在其他语言中，只有在需要的时候才创建类。但是js一般写好所有类。

**
View之间有顺序。比如，B只能在A之后执行。
假设有连续的A，B，C三个View，A获取了一张用户打开的图片，B接受图片并且预览，再在C中编辑。C中编辑了一般，决定丢弃工作，返回上一页。这时，B的状态已经改变了，不能再重新创建实例。一开始的B是不包含图片的，但是现在包含了一张特定的图片。
可以从生命周期的视角来考虑。
这主要涉及数据的传递。
A传递数据给B，B的状态就改变了。B在进入C，C如果想要返回B，就需要返回那个状态改变了的B，因为B中保存着数据。如果重新实例化，就清除了B中的数据。
这其实是数据的保存问题。
比如A创建了数据data1，然后跳转至B。那么，A是否还需要继续保存数据data1？如果不必，就可以销毁，如果需要，就必须使用之前的A。
其实无论哪种情况都可以不销毁，因为View都是单例模式。可以写一个reset方法清除数据，返回初始化的状态。


** View的数据更新
View保存着数据。有些是自己创建的，有些是用户输入的，有些需要利用前一个View传递的数据。
比如A有数据data1，传递给B，B据此创建数据data2，那么重新由A进入B之后，B的data2必然会重建。
比如有经A，B，C的数据传递。如果A的数据改变了，那么B和C之前保存的旧数据就无用了。

**
这样看来，在初始时创建所有的View实例是可行的。虽然有些实例此时还没有准备好。比如B需要A传递的图片才能展示；B的元素不齐备，因此无法添加事件监听。
这些一方面可以通过修改设计避免；另一方面，由于只有在得到传递的数据之后才会展示，就避免了问题。


**
页面是单例的，但是又是继承了父类的。
这给我们提出了挑战。

单例模式，就只有唯一的数据。
只继承方法，不继承数据


** 框架法
View是一个框架，提供了完成一项任务的必要的属性和方法。
所有的具体的View都是一个实例，并且是唯一的实例。不能有两个View指向同一个页面。
这时，就可以将View定位类，而将具体的View定位View的实例。
然后对具体的View添加独有的方法和属性，完成具体实例的定制。
这就充分的利用了js的特性，有避免了一味模仿其他语言带来的不协调。
实际上，我目前还没有找到完美实现类似java的类和继承的实现。
比如，如何继承静态类和静态方法，这是我没有实现的。
及时能实现，也要经过一番思考。我这里就先放下了。以后有时间可以想一想。

这里的需求是这样的：
有多个对象，它们之间有重复之处。因此，为了提高复用性、规范性（所有的对象都实现了某些接口），我们使用了类和继承。但是，显然，本来这些对象是独一无二的，我们是“为了实现规范性而引进了类和继承”，这带来了一个副作用，就是本来独一无二的对象现在成了类，反而要进行更多的设计来实现单例模式。这是java的思维方式，不是js的思维方式。
js的一个特性就是，一个对象可以是一个类的实例，是使用new语句达到的。但是，我们可以对这个对象本身可以进行任意的修改。因此改进后的方案是：仅仅设计一个类，用这个类实例化多个对象，然后分别对每个对象进行定制。
在java语言中，如果我们想为某个对象进行修改，增加一些属性和方法，唯一的方法是继承原来对象的类，设计一个子类，然后实例化子类。每进行一种定制，都必须设计一种新的子类。这是java的思维方式。
但是在js中，一个对象，你可以进行任意的修改，而不必事先实现一个子类。

更本质的说：
在java中，想要得到一个对象，我们需要设计一个类，然后实例化该类。
在js中，想要得到一个对象，我们声明这个变量是一个对象，然后定制这个对象。
在java中，先有定制的类，再有定制的对象。
在js中，先有一般的对象对象，再有定制的对象。

因此，js的这种特性机极其适合实现类似单例模式的效果。

如果有多重继承，那么我们可以首先设计多层次的继承的类，但是在实例的上一层止住，最具体的那个实例直接实现，不经由类。

也就是说，类实现复用，对象实现定制。


类中可以声明一些方法，但是是空的方法。这没有实际的以及，只是用来提醒编程者：这需要在子类或者实例中实现，类似于抽象方法。
这时，我们对它们可以赋值为undefined或者null。在实际的效果上是一样的。
我们可以约定：使用undefined或者干脆不赋值，表示是一个抽象方法，要在子类或者对象中实现；使用null表示是在本对象中使用的，只是没有初始化，用null占个位。

上面的话有问题！
假设A中有抽象方法f1，在方法f2中使用了f1。但是A实际上并不要求实例a实现f1。这个时候，f2调用会出错。
因此，还是抽象方法还是使用function() {}吧。


**
View的实例在定制时的获取view和页面元素的操作必须在页面加载完成之后再进行，因此必须放到init方法中。不能放在函数外，否则会在引入文件时被执行，这时页面尚未加载完成。

放到里面去之后，使用this做元素的前缀，更好了。

现在看起来，这个View类和它的实例像极了Android的Activity和MainActivity。

**
View实例定制的属性分为数据和页面元素。页面元素大部分用于添加事件，用处不大，感觉都没有必要写一个名字来引用。